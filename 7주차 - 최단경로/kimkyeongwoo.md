# 김경우
## 다익스트라 알고리즘
### (1) 요약
단일 출발지, 최단경로 해결 알고리즘

비가중치 그래프나 양의 가중치 그래프에서 특정 출발 노드에서 다른 모든 노드까지의 최단 경로를 찾는데 사용

**그래프**에서 사용한다. (따라서 간선과 노드 존재)

다익스트라 알고리즘을 적용하기 위해서는 간선의 **가중치**가 **양수**여야함

구현은 **최소합**이나 **우선순위 큐**로 가능함.

---
### (2) 동작
1. 먼저 출발 노드를 설정한다. 이 노드의 최단거리를 0으로 설정하고 나머지 노드들은 모두 최단거리를 무한댈호 설정한다.

2. 큐에서 현재까지의 최단 거리가 가장 짧은 노드를 선택해서 방문한다.

3. 방문한 노드의 이웃들을 살펴보는데, 처음에 정한 출발 노드부터 이웃 노드까지의 최단 거리를 계산하고, 이 값이 기존의 기록된 거리보다 짧다면 최단 거리를 갱신한다.

4. 이웃 노드의 최단 거리가 새롭게 갱신되었다면 해당 이웃 노드를 큐에 다시 추가한다.

5. 2부터 4까지의 과정을 반복한다.

6. 큐가 텅텅 비었으면 끝.
---
### (3) 예시
````
A ---3--- B
|         |
6         5
|         |
C ---2--- D


1단계 A(0), B(∞), C(∞), D(∞)

2단계 A(0), B(3), C(6), D(∞)

3단계 A(0), B(3), C(6), D(8)

4단계 A(0), B(3), C(6), D(8)
````



---
## 벨만 포드 알고리즘
### (1) 요약
단일 출발지, 최단 경로 알고리즘

출발 노드에서 다른 모든 노드까지의 최단 경로를 찾는다.

다익스트라와 달리 음수 가중치가 있는 그래프에서도 사용가능하다.

또한 음수 사이클 감지 가능하다.

### (2) 동작 
1. 출발 노드를 0으로 설정하고 나머지 노드들을 무한대로 설정한다.

2. 그래프에 있는 모든 간선에 대해서 각 간선을 V-1먼 반복하고 최단 거리를 찾는다. (V는 노드 개수)

3. 각 간선에 대해서 계산한 경로가 최단 거리면 최단 거리를 갱신한다.

4. V-1번 반복 후 마지막에 모든 간선을 한번 더 체크하고, 최단 거리가 줄어든 간선이 있다면 음수 사이클이 존재한다고 판명한다. 이때는 최단 경로가 존재하지 않는다.

### (3) 예시
````
      4          5
  A -----> B --------> C
  |        ^         /
  |        |       /
  | 1      | -2  /  -3
  v        |   /
  D -----> E <-
     3

A -> B: B의 거리 = 0 + 4 = 4
A -> D: D의 거리 = 0 + 1 = 1
D -> E: E의 거리 = 1 + 3 = 4
E -> B: B의 거리 = min(4, 4 - 2) = 2 (업데이트)
B -> C: C의 거리 = 2 + 5 = 7
E -> C: C의 거리 = min(7, 4 - 3) = 1 (업데이트)

````
## 플로이드 워셀 알고리즘
### (1) 요약
모든 쌍, 최단 경로 해결 알고리즘

그래프에 존재하는 모든 노드들 간의 최단 경로를 구할 수 있다.

간선이 음수 가중치를 가져도 사용 가능하다.

통상 동적 계획법을 쓴다.

### (2) 동작
1. 모든 노드 쌍(i,j)을 초기화

2. 초기화는 각 노드쌍에 부여된 가중치로 설정한다.

3. 경로가 없으면 무한대

4. (1,1) 이런 애들은 경로를 0으로.

5. 모든 노드를 중간 노드로 사용해서 i에서 j로 가는 최단 경로를 찾음.

6. 만약 i에서 j로 가는데 k를 거쳐가는 경로랑 직접 가는 경로랑 비교해서 작은 것 선택.

7. 모든 과정을 노드 쌍에 대해서 반복

### (3) 예시
````
         3
   (A) ------> (B)
    |       /   | 
  8 |     1     | -4
    |   /       v
   (C) <------ (D)
         2

1단계
초기 거리 행렬:
   A   B   C   D
A  0   3   8   ∞
B  ∞   0   ∞  -4
C  ∞   ∞   0   2
D  ∞   1   ∞   0

2단계
   A   B   C   D
A  0   3   8  -1  (갱신됨: A -> B -> D = 3 - 4 = -1)
B  ∞   0   ∞  -4
C  ∞   ∞   0   2
D  ∞   1   ∞   0

3단계
   A   B   C   D
A  0   3   8  -1
B  ∞   0   1  -4  (갱신됨: B -> D -> C = -4 + 2 = -2)
C  ∞   3   0   2
D  ∞   1   ∞   0

4단계
최종 거리 행렬:
   A   B   C   D
A  0   3   8  -1
B  ∞   0   1  -4
C  ∞   3   0   2
D  ∞   1   ∞   0
````


--- 
### 다익스트라 문제: 프로그래머스: 배달
````javascript
function solution(N, road, K) {
    var answer = 0;

    // 노드를 번호로 직접 접근하기 위해 N+1개 생성하고 무한대로 초기화
    // 방문 체크 배열도 생성
    var distance = Array(N+1).fill(Infinity);
    var visited = Array(N+1).fill(false);
    
    // 출발점 세팅
    distance[1] = 0;
    var queue = [[1,0]];
    
    // 사실상 BFS인데, 매 순간 정렬을 첨가한.
    while(queue.length !== 0) {
        // 가장 거리가 짧은 순으로 정렬
        queue.sort((a,b) => a[1] - b[1]);

        // 정렬 후 가장 짧은 놈 대려오기
        const [start, dist] = queue.shift();
        
        // 이미 방문했던 지점이면 점프
        if(visited[start]) continue;
        visited[start] = true;
        
        // 꺼낸 노드가 어디랑 연결되어있는지 확인하기
        road.forEach(([a,b,c])=> {
            // road 중에서 a나 b가 꺼낸 노드의 start면 연결되어있는거니까 최단 거리 갱신 체크
            if(start === a || start === b) {
                const renewDistance = dist + c;
                const nextNode = (a === start ? b : a)
                
                // 만약에 최단거리가 갱신된거면 갱신된 녀석을 다시 큐에 집어넣기
                if(renewDistance < distance[nextNode]) {
                    distance[nextNode] = renewDistance;
                    queue.push([nextNode, renewDistance])
                }
            }
        })
    }
    
    console.log(distance)

    return distance.filter((dist)=> dist <= K).length;
}
````

--- 

