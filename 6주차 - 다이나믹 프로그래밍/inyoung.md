# 6주차-다이나믹 프로그래밍 (DP)

## 다이나믹 프로그래밍 
- 통상적으로 메모리를 더 사용하여 시간 복잡도를 개선할 때 많이 사용됨
- 시간 복잡도가 비효율적인 알고리즘이 있을 때, `부분 문제의 반복`이  발생하는 경우 적용하면 효과적임.
- `점화식`을 찾는 것이 핵심적인 과정이다.

## 사용 조건
두가지 조건을 만족할 때 사용
1. 최적 부분 구조 
- 큰 문제를 유사한 형태를 작은 문제를 나눌 수 있으며, 작은 문제의 답을 모아 큰 문제를 해결한다.

2. 반복되는 부분 문제
- 동일한 작은 문제를 반복적으로 해결해야 한다.


## 점화식과 최적 부분 구조 

ex) 피보나치 수열:[1,1,2,3,5,8,13..]
-  점화식: 인접한 항으로 현재 값을 결정하는 관계식을 의미한다.

최적 부분 구조를 만족한다는 특징이 있다.

## 점화식의 구성 요소 
- 점화식의 기본적인 구성 요소는 다음과 같다.

1. 초기항
2. 인접한 항과의 관계
- 점화식은 ⭐️**재귀 함수**로 표현할 수 있다.
- 재귀 함수는 ⭐️**종료 조건**이 있어야 하는데, 이것이 점화식의 초기항과 같은 역할을 수행한다.

```js
// 피보나치 함수의 점화식을 그대로 재귀 함수로 구현
function fibo(x){
    if (x==1) return 1; // 종료 조건이 없으면 무한루프.
    return fibo (x-1) + fibo(x-2); // 점화식 부분
}
```

- 중북되는 문제 발생  (이미 구한 값을 불필요하게 계산)

DP로 이를 해결해보자.

```js

d= Array(100).fill(0);

function fibo(x){
    if (x==1 || x===2){
        return 1;
    }
    if (d[x] !==0){
        return d[x];
    }
    d[x] = fibo(x-1) + fibo(x-2);
    return d[x];
}

console.log(fibo(99));

```

- 다이나믹 프로그래밍 (재귀 함수)의 대표적인 코드 형식은 다음과 같다.
```js
function dp(){
1. 종료조건 
2. 이미 해결한 문제라면, 정답을 그대로 반환
3. 점화식에 따라 정답 게산
}
```

## 문제 접근 순서
- 다이나믹 프고르맹 문제 해결 접근 순서는 다음과 같다.
1. 문제 이해하기
2. 점화식 찾아내기 -> 일반적으로 가장 핵심적인 부분이다.
3. 구현 방식 (상향식/하향식) 결정하기
4. 점화식을 실제 코드로 구현하기


## 다이나믹 프로그래밍 문제 접근 방법
- 다이나믹 프로그래밍 문제는 두 가지 방법으로 접근할 수 있다.

1. 상향식 : 반복문을 이용해 초기 항부터 계산한다.
2. 하향식: 재귀 함수로 큰 항을 구하기 위해 작은(이전) 항을 호출하는 방식이다.

--> 이미 구한 함수 값을 담는 테이블을 흔히 DP 테이블이라고 한다.


```js
// 피보나치 수열 (하향식)
d= new Array(100).fill(0);

function fibo(x){
    if (x==1 || x==2){
        return 1;
    }
    if (d[x] !=0){
        return d[x];
    }
    d[x] = fibo(x-1) + fibo(x-2);
    return d[x];
}

console.log(fibo(99));

```


```js
// 피보나치 수열 (상향식)
d= new Array(100).fill(0);

d[1] =1;
d[2]=1;
n=99;
// 보텀업 다이나믹 프로그래밍
for (let i=3;i<=n;i++){
    d[i] = d[i-1] + d[i-2];
}

console.log(d[n]);

```


## 문제: N으로 표현

동적계획법(Dynamic Programming) 사용

```js
function solution(N, number) {
    // 가능한 최솟값은 1부터 최대 8까지 사용
    const dp = Array.from({ length: 9 }, () => new Set());
    for (let i = 1; i <= 8; i++) {
        // N을 i번 사용해서 만들 수 있는 수를 기본적으로 추가
        dp[i].add(Number(String(N).repeat(i)));
        // j와 (i-j)를 이용하여 새로운 숫자들을 생성
        for (let j = 1; j < i; j++) {
            for (let op1 of dp[j]) {
                for (let op2 of dp[i - j]) {
                    dp[i].add(op1 + op2);
                    dp[i].add(op1 - op2);
                    dp[i].add(op1 * op2);
                    if (op2 !== 0) {
                        dp[i].add(Math.floor(op1 / op2));
                    }
                }
            }
        }
        // number가 만들어졌으면 바로 i를 반환
        if (dp[i].has(number)) {
            return i;
        }
    }
    // 8번 이내에 만들 수 없으면 -1 반환
    return -1;
}
```

dp 배열에 숫자 N을 사용한 횟수를 인덱스로 하여 배열의 값으로 최소 인덱스 만큼 N을 사용하여 표현할 수 있는 수들의 집합을 저장한다. 예를 들어, N을 최소 3번 사용하여 표현할 수 있는 수들은 모두 dp[3]의 집합에 저장하는 방식이다.

 
```
dp[1]은 N을 1회 사용한 값들이 들어가야 하는데 이는 N 하나로 유일하다.

dp[2]는 N을 1회 사용한 값, 즉 dp[1]의 값 중 두 개를 연산하여 만들 수 있다.

dp[3]은 dp[1]의 값 중 하나와 dp[2]의 값 중 하나를 연산하여 만들 수 있다.

dp[4]는 dp[1]의 값 중 하나와 dp[3]의 값 중 하나를 연산하거나, dp[2]의 값 중 두 개를 연산하여 만들 수 있다.
```
즉 dp[n]은 dp[1]의 값 중 하나와 dp[n - 1]의 값 중 하나를 연산하거나, .... , dp[n - 1]의 값 중 하나와 dp[1]의 값 중 하나를 연산하여 만들 수 있다.

 

예를 들어 N = 5이면,

dp[1] = Set { 5 }, dp[2]는 5 + 5, 5 - 5, 5 * 5, 5 / 5의 값들이 모두 가능하므로 dp[2] = Set { 0, 1, 10, 25 }이다. 

그런데 사실 55라는 수도 dp[2]에 속해야 한다. 5를 두개 이어 붙이는 경우도 가능하기 때문이다.

이런 경우를 생각해서 dp[n]을 계산할 때 항상 먼저 N이 n번 반복되는 수를 추가해줘야 한다. 따라서 dp[2] = Set { 0, 1, 10, 25, 55 }이다. dp[3]은 dp[2]의 5개의 수끼리 사칙연산한 결과와 555를 포함한 집합이다.

dp[3] = Set { -50, -20, -5, -4, 0, 2, 4, 5, 6, 11, 15, 20, 30, 50, 60, 125, 275, 555, Infinity }

집합에 음수와 Infinity같은 값들이 들어가는 것은 사칙연산시 피연산자들의 범위를 제한하지 않아서이다. 피연산자의 범위를 음수와 무한대가 나오지 않도록 조정한 것과 조정하지 않은 것은 문제 풀이와 속도에 큰 차이가 없기 때문에 무시하겠다. 만약 이렇게 풀려면 아래와 같이 뺄셈과 나눗셈의 경우에 조건문을 추가하면 된다.

이렇게 dp[n]는 합이 n이 되는 i, j의 dp[i]의 값들과 dp[j]의 값들의 연산 결과를 모두 구하면 된다. 그리고 dp[n]에 대한 연산이 끝날 때마다 dp[n]의 집합에 number가 포함되어 있는지 확인 후, 존재한다면 그 즉시 n을 반환한다. 

dp[n + a] 에서 number가 나온다고 해도 구하고자 하는 값은 가장 작은 n이기 때문에 더 이상 탐색을 하지 않아도 된다. 문제의 조건에 따라 만약 모든 dp[8]까지 구했는데도 number가 포함되어 있는 dp[n]이 없다면 -1을 반환하면 된다.